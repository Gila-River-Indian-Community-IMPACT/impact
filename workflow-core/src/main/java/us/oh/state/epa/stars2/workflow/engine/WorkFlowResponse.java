package us.oh.state.epa.stars2.workflow.engine;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.ArrayList;

/**
 * <p>
 * Title: WorkFlowResponse
 * </p>
 * 
 * <p>
 * Description: This class returns the results of a WorkFlow request or action
 * issued to the WorkFlowEngine by another application via the WorkFlowManager.
 * It provides a status indication plus all messages generated by the
 * WorkFlowEngine.
 * </p>
 * 
 * <p>
 * The status indicator consists of one of three values: (1) The request was
 * successful (ok). (2) The request could not be fulfilled (failed) due to a
 * lack of resources or other non-software problem. (3) The request could not be
 * fulfilled due to a software error (error). The returned status request will
 * always reflect the highest severity failure, with "error" being the most
 * severe failure code and "ok" being the least severe failure code.
 * </p>
 * 
 * <p>
 * If the status indicator is "failed" or "error", all error messages generated
 * by the WorkFlowEngine can be retrieved via "getMessages()".
 * </p>
 * 
 * <p>
 * Copyright: Copyright (c) 2004
 * </p>
 * <p>
 * Company: MentorGen, LLC
 * </p>
 * 
 * @author Sam Wooster
 */

public class WorkFlowResponse implements Serializable {
	
	private static final long serialVersionUID = 2075766286562773633L;
	
    /**
     * Status indicator for successful completion of a workflow request.
     */
    public static final String OK = "ok";

    /**
     * Status indicator for workflow request failure (no-software problem).
     */
    public static final String FAILED = "failed";

    /**
     * Status indicator for workflow request failure due to software error.
     */
    public static final String ERROR = "error";
    private String status;
    private ArrayList<String> errorMsgs;
    private ArrayList<String> failureMsgs;
    private ArrayList<String> infoMsgs;
    private ArrayList<DataSpec> data;
    private ArrayList<Integer> cancellationIds;

    // The WorkFlowManager will fill in these values as needed. They don't
    // need to be serialized across the socket connection.
    private transient boolean rollbackNeeded;
    private transient ArrayList<String> recommendations;

    /**
     * Constructor. Builds an object with a "success" status indicator.
     */
    public WorkFlowResponse() {
        status = WorkFlowResponse.OK;
        rollbackNeeded = false;
        errorMsgs = new ArrayList<String>();
        failureMsgs = new ArrayList<String>();
        infoMsgs = new ArrayList<String>();
        data = new ArrayList<DataSpec>();
        recommendations = new ArrayList<String>();
        cancellationIds = new ArrayList<Integer>();
    }

    /**
     * Sets the cancellation order Id. This is done by the workflow engine when
     * it generates a cancellation order.
     * 
     * @param cancelIds
     *            ArrayList of Integer cancellation order Ids.
     */
    public final void setCancellationIds(ArrayList<Integer> cancelIds) {
        if (cancelIds == null) {
            cancellationIds = new ArrayList<Integer>();
        } else {
            cancellationIds.addAll(cancelIds);
        }
    }

    /**
     * Returns the cancellation order Id. If the workflow engine did not need to
     * create a cancellation order.
     * 
     * @return Integer Cancellation order Id.
     */
    public final Integer[] getCancellationIds() {
        if (cancellationIds == null) {
            cancellationIds = new ArrayList<Integer>();
        }

        return cancellationIds.toArray(new Integer[0]);
    }

    /**
     * Adds an informational message to this object. Informational messages are
     * typically used when some action failed, but the failure recovery was
     * successful. In that case, no real failure or error has occurred and the
     * message is included simply as information. Response status is not altered
     * in any way. If the <code>message</code> is null or empty, then the
     * message is ignored.
     * 
     * @param message
     *            Message to be added to the response.
     */
    public final void addInfoMsg(String message) {
        if ((message != null) && (message.length() > 0)) {
            infoMsgs.add(message);
        }
    }

    /**
     * Adds a failure message to this object. If the <code>message</code> is
     * null or empty, then the message is ignored and the status code is not
     * altered. Otherwise, the message is appended to the current set of
     * messages and the status code is set to "FAILED" unless it is already
     * "ERROR", in which case the status code is not altered.
     * 
     * @param message
     *            Failure message.
     */
    public final void addFailure(String message) {
        if ((message != null) && (message.length() > 0)) {
            failureMsgs.add(message);

            if (status.compareToIgnoreCase(WorkFlowResponse.OK) == 0) {
                status = WorkFlowResponse.FAILED;
            }
        }
    }

    /**
     * Adds an Error message to this object. If the <code>message</code> is
     * null or empty, then the message is ignored and the status code is not
     * altered. Otherwise, the message is appended to the current set of
     * messages and the status code is set to "ERROR".
     * 
     * @param message
     *            Error message.
     */
    public final void addError(String message) {
        if ((message != null) && (message.length() > 0)) {
            errorMsgs.add(message);
            status = WorkFlowResponse.ERROR;
        }
    }

    /**
     * Adds an Exception error message to the error list for this object.
     * Basically, the exception message is added to the list of error messages.
     * If the exception has no error message, e.g., a NullPointerException, then
     * the class name of the Exception is added to the error list.
     * 
     * @param e
     *            Exception Exception whose message is added to the error list.
     */
    public final void addException(Exception e) {
        String msg = e.getMessage();

        if ((msg == null) || (msg.length() == 0)) {
            msg = e.getClass().getName();
        }

        addError(msg);
    }

    /**
     * Adds a recommendation message to this object. If the <code>message</code>
     * is null or empty, then the message is ignored. Otherwise, the message is
     * appended to the current set of recommendations.
     * 
     * @param message
     *            Recommendation message
     */
    public final void addRecommendation(String message) {
        if ((message != null) && (message.length() > 0)) {
            recommendations.add(message);
        }
    }

    /**
     * Returns "true" if the work flow request was successful. Otherwise,
     * returns "false".
     * 
     * @return boolean "True" if request was successful.
     */
    public final boolean isSuccess() {
        return (status.compareToIgnoreCase(WorkFlowResponse.OK) == 0);
    }

    /**
     * Returns "true" if the work flow request failed due to a non-software
     * error. Otherwise, returns "false".
     * 
     * @return boolean "True" if request failed.
     */
    public final boolean hasFailed() {
        return (status.compareToIgnoreCase(WorkFlowResponse.FAILED) == 0);
    }

    /**
     * Returns "true" if the work flow request failed due to a software error.
     * Otherwise, returns "false".
     * 
     * @return boolean "True" if request failed.
     */
    public final boolean hasError() {
        return (status.compareToIgnoreCase(WorkFlowResponse.ERROR) == 0);
    }

    /**
     * Returns the <tt>String</tt> version of the status code.
     * 
     * @return String status code.
     */
    public final String getStatusCode() {
        return status;
    }

    /**
     * Returns an array of all error messages generated by the WorkFlowEngine
     * while processing a request. If there were no messages, then the returned
     * list will be empty (or null). NOTE: This object may have messages even if
     * the original request succeeded.
     * 
     * @return String[] All error messages generated by the WorkFlowEngine.
     */
    public final String[] getErrorMessages() {
        return errorMsgs.toArray(new String[0]);
    }

    /**
     * Returns an array of all failure messages generated by the WorkFlowEngine
     * while processing a request. If there were no messages, then the returned
     * list will be empty (or null). NOTE: This object may have messages even if
     * the original request succeeded.
     * 
     * @return String[] All failure messages generated by the WorkFlowEngine.
     */
    public final String[] getFailureMessages() {
        return failureMsgs.toArray(new String[0]);
    }

    /**
     * Returns an array of all info messages generated by the WorkFlowEngine
     * while processing a request. If there were no messages, then the returned
     * list will be empty (or null).
     * 
     * @return String[] All info messages generated by the WorkFlowEngine.
     */
    public final String[] getInfoMessages() {
        return infoMsgs.toArray(new String[0]);
    }

    /**
     * Returns an array of all recommendation messages generated by the
     * WorkFlowManager while processing a request. If there are no messages,
     * then the returned listwill be empty (or null).
     * 
     * @return String[] All recommendations generated by the WorkFlowManager.
     */
    public final String[] getRecommendationMessages() {
        return recommendations.toArray(new String[0]);
    }

    /**
     * Appends the contents of <code>wfr</code> to this object. This is useful
     * for command chaining in the WorkFlowEngine. Note that the status of this
     * object is updated to reflect the maximum accumulated status. This means
     * that if <code>wfr</code> or this object has a current status of
     * "ERROR", then the final status will be "ERROR". Similarly, if either
     * object records a failure status, the final status will be "FAILED".
     * 
     * @param wfr
     *            Object to be merged into this object.
     */
    public final void append(WorkFlowResponse wfr) {
        // Append "wfr"s messages to our messages.
        errorMsgs.addAll(wfr.errorMsgs);
        failureMsgs.addAll(wfr.failureMsgs);
        infoMsgs.addAll(wfr.infoMsgs);
        recommendations.addAll(wfr.recommendations);

        rollbackNeeded |= wfr.rollbackNeeded;

        // If either object shows ERROR, mark our status as ERROR.
        if (wfr.hasError() || hasError()) {
            status = WorkFlowResponse.ERROR;
        } else if (wfr.hasFailed() || hasFailed()) {
        // If either object shows FAILED, mark our status as FAILED.
            status = WorkFlowResponse.FAILED;
        }
    }

    /**
     * Adds a data specification to the request. Data specs identify service
     * data that is typically manipulated during workflow process. Often, these
     * values are displayed to the user during check-in/check-out. The data name
     * associates this value with a display object in the web application. The
     * "type" identifies the data type, e.g., "String", "Integer", etc.
     * 
     * @param name
     *            Data object name.
     * @param customDetailTypeId
     *            Data type id.
     * @param value
     *            Data object value.
     * 
     * @return int The index of this pair in the array of data pairs.
     */
    public final int addDataSpec(String name, Integer customDetailTypeId, String value) {
        int idx = data.size();

        DataSpec dp = new DataSpec();
        dp.name = name;
        // dp.type = type ;
        dp.customDetailTypeId = customDetailTypeId;
        dp.value = "";

        if (value != null) {
            dp.value = value;
        }

        data.add(dp);
        return idx;
    }

    /**
     * Returns the total number of data pairs assigned to this object. To access
     * individual values, use this method to retrieve the count, and then
     * iterate over the number of values to retrieve data names via the
     * "getDataName()" method and data values via the "getDataValue()" method.
     * 
     * @return int total number of data pairs in this object.
     */
    public final int getDataCount() {
        return data.size();
    }

    /**
     * Returns the "idx" data name. If "idx" is out of range (see
     * "getDataCount()"), then a runtime exception will be generated. Values are
     * always returned in the same order they are added.
     * 
     * @param idx
     *            index into the data pairs array.
     * 
     * @return String data object name.
     */
    public final String getDataName(int idx) {
        DataSpec dp = data.get(idx);
        return dp.name;
    }

    /**
     * Returns the "idx" data type. If "idx" is out of range (see
     * "getDataCount()"), then a runtime exception will be generated. Values are
     * always returned in the same order they are added.
     * 
     * @param idx
     *            index into the data pairs array.
     * 
     * @return String data object type.
     */
    public final Integer getCustomDetailTypeId(int idx) {
        DataSpec dp = data.get(idx);
        return dp.customDetailTypeId;
    }

    /**
     * Returns the "idx" data value. If "idx" is out of range (see
     * "getDataCount()"), then a runtime exception will be generated. Values are
     * always returned in the same order they are added.
     * 
     * @param idx
     *            index into the data pairs array.
     * 
     * @return String data object value.
     */
    public final String getDataValue(int idx) {
        DataSpec dp = data.get(idx);
        return dp.value;
    }

    /**
     * Returns the current value of the "rollback needed" flag. If this is
     * "true", then the provisioning subsystem recommends that the calling
     * application undo any database transactions that it may have done prior to
     * calling the WorkFlowManager.
     * 
     * @return boolean "true" if database action should be undone.
     */
    public final boolean getRollbackNeeded() {
        return rollbackNeeded;
    }

    /**
     * Allows provisioning components to set the value of the "rollback needed"
     * flag. Often, the application must perform some form of database update
     * prior to sending a request to the workflow subsystem. If that action
     * fails, then the workflow subsystem will set this value to "true" to
     * indicate to the calling application that the database update should be
     * undone.
     * 
     * @param rbn
     *            "true" if any prior database update should be undone.
     */
    final void setRollbackNeeded(boolean rbn) {
        rollbackNeeded = rbn;
    }

    /**
     * Returns a string that represents the contents of this object. The output
     * is similar to the legacy output, but not identical (the legacy technique
     * did not include error messages).
     * 
     * @return String A string representation of this object.
     */
    public final String toString() {
        StringBuffer sb = new StringBuffer(300);

        // First, output the status, all by itself.
        sb.append(status);

        sb.append(":Cancellation Ids:");
        addIntegers(cancellationIds, sb);

        // Next, append any messages we may have accumulated.
        sb.append(":Errors:");
        addMessages(errorMsgs, sb);

        sb.append(":Failures:");
        addMessages(failureMsgs, sb);

        sb.append(":Info:");
        addMessages(infoMsgs, sb);

        sb.append(":Recommendations:");
        addMessages(recommendations, sb);

        sb.append(":Rollback Needed=");

        if (rollbackNeeded) {
            sb.append("true:");
        } else {
            sb.append("false:");
        }

        // Now, append any data specifications we may have.
        int dataCnt = data.size();

        if (dataCnt > 0) {
            int i = 0;
            int lastIdx = dataCnt - 1;
            sb.append(",");

            for (DataSpec dp : data) {
                if (i++ < lastIdx) {
                    sb.append(",");
                }

                sb.append("Data=");
                sb.append(dp.name);
                sb.append(":");
                // sb.append (dp.type) ;
                // sb.append (":") ;
                sb.append(dp.customDetailTypeId.toString());
                sb.append(":");
                sb.append(dp.value);
            }
        }

        return sb.toString();
    }

    /**
     * Appends all of the messages in "msgList" to the StringBuffer "sb" with
     * each message separated by commas.
     * 
     * @param msgList
     *            ArrayList of String messages.
     * @param sb
     *            Output StringBuffer being constructed.
     */
    private void addMessages(ArrayList<String> msgList, StringBuffer sb) {
        // If we have no messages, then we have nothing to append.
        if ((msgList != null) && (msgList.size() > 0)) {
            int i = 0;
            int lastIdx = msgList.size() - 1;

            for (String msg : msgList.toArray(new String[0])) {
                sb.append(msg);

                if (i++ < lastIdx) {
                    sb.append(",");
                }
            }
        }
    }

    /**
     * Appends all of the Integers in "intArray" to the StringBuffer "sb" with
     * each Integer separated by commas.
     * 
     * @param intArray
     *            ArrayList of Integers.
     * @param sb
     *            Output StringBuffer being constructed.
     */
    private void addIntegers(ArrayList<Integer> intArray, StringBuffer sb) {
        if ((intArray != null) && (intArray.size() > 0)) {
            int i = 0;
            int lastIdx = intArray.size() - 1;

            for (Integer intValue : intArray.toArray(new Integer[0])) {
                sb.append(intValue.toString());

                if (i < lastIdx) {
                    sb.append(",");
                }
            }
        }
    }

    /**
     * Streaming method. Used during object streaming to provide a more
     * efficient mechanism than that standard Serializable implementation.
     * 
     * @param stream
     *            The output stream.
     * 
     * @throws IOException
     *             Streaming exceptions.
     */
    private void writeObject(java.io.ObjectOutputStream stream)
            throws IOException {
        // Write the status indicator to the stream.
        stream.writeUTF(status);

        // Write the Cancellation Order IDs.
        int idCnt = cancellationIds.size();
        stream.writeUTF(Integer.toString(idCnt));
        int i;

        for (i = 0; i < idCnt; i++) {
            Integer orderId = cancellationIds.get(i);
            stream.writeUTF(orderId.toString());
        }

        // Write the rollback flag.
        String rollback = Boolean.toString(rollbackNeeded);
        stream.writeUTF(rollback);

        // Stream each message list individually.
        writeMessageList(stream, errorMsgs);
        writeMessageList(stream, failureMsgs);
        writeMessageList(stream, infoMsgs);
        writeMessageList(stream, recommendations);

        // Write the total number of data specs we had and then each of the
        // data specs.
        int dataCnt = data.size();
        stream.writeUTF(Integer.toString(dataCnt));

        for (i = 0; i < dataCnt; i++) {
            DataSpec ds = data.get(i);

            writeString(stream, ds.name);
            // writeString (stream, ds.type) ;
            writeString(stream, ds.customDetailTypeId.toString());
            writeString(stream, ds.value);
        }

        stream.flush();
    }

    /**
     * Writes String "s" to "stream". If "s" is null, writes an empty string
     * instead.
     * 
     * @param stream
     *            ObjectOutputStream to write "s" to.
     * @param s
     *            String to be written to "stream".
     * 
     * @throws IOException
     *             Streaming exception.
     */
    private void writeString(java.io.ObjectOutputStream stream, String s)
            throws IOException {
        if (s == null) {
            stream.writeUTF(new String(""));
        } else {
            stream.writeUTF(s);
        }
    }

    /**
     * Streaming method. Used during object streaming to provide a more
     * efficient mechanism than that standard Serializable implementation.
     * 
     * @param stream
     *            The input stream.
     * 
     * @throws IOException
     *             Streaming Exception
     * @throws java.lang.ClassNotFoundException
     *             Could not create data object.
     */
    private void readObject(java.io.ObjectInputStream stream)
            throws IOException {
        // Read the status indicator.
        status = stream.readUTF();

        // Read the cancellation order Id.
        String s = stream.readUTF();
        Integer temp = new Integer(s);
        int idCnt = temp.intValue();
        cancellationIds = new ArrayList<Integer>();

        int i;
        for (i = 0; i < idCnt; i++) {
            cancellationIds.add(new Integer(stream.readUTF()));
        }

        // Read the rollback needed indicator.
        String rbNeeded = stream.readUTF();
        Boolean btemp = new Boolean(rbNeeded);
        rollbackNeeded = btemp.booleanValue();

        // Read in all of the messages.
        errorMsgs = readMessageList(stream);
        failureMsgs = readMessageList(stream);
        infoMsgs = readMessageList(stream);
        recommendations = readMessageList(stream);

        // Read in all of the DataSpecs.
        s = stream.readUTF();
        temp = new Integer(s);
        int dataCnt = temp.intValue();
        data = new ArrayList<DataSpec>(dataCnt);

        DataSpec dp;

        for (i = 0; i < dataCnt; i++) {
            dp = new DataSpec();

            dp.name = stream.readUTF();
            // dp.type = stream.readUTF() ;
            dp.customDetailTypeId = Integer.decode(stream.readUTF());
            dp.value = stream.readUTF();

            data.add(dp);
        }
    }

    /**
     * Writes a message list to stream. The message list is written as the total
     * number of messages (which could be zero) followed by each message in
     * "msgList".
     * 
     * @param stream
     *            ObjectOutputStream we are writing to.
     * @param msgList
     *            The list of messages to write to the stream.
     * 
     * @throws IOException
     *             Streaming exception.
     */
    private void writeMessageList(ObjectOutputStream stream,
            ArrayList<String> msgList) throws IOException {
        int msgCnt = 0;

        // If the message list is null or empty, then we have no messages to
        // output. Just output a zero so the reader will know there are no
        // messages.
        if ((msgList != null) && (msgList.size() > 0)) {
            // We have messages. For each message, output the message.
            msgCnt = msgList.size();
            stream.writeUTF(Integer.toString(msgCnt));

            for (String msg : msgList.toArray(new String[0])) {
                stream.writeUTF(msg);
            }
        } else {
            stream.writeUTF(Integer.toString(msgCnt));
        }
    }

    /**
     * Read a message list from a stream. This is the inverse of
     * "writeMessageList()". The message list is read as the total number of
     * messages (which could be zero) followed by each message in the stream.
     * 
     * @param stream
     *            ObjectInputStream containing messages.
     * 
     * @return msgList ArrayList containing the next set of messages read in.
     * 
     * @throws IOException
     *             Streaming exception.
     */
    private ArrayList<String> readMessageList(ObjectInputStream stream)
            throws IOException {
        // Read in the total number of messages to process.
        String s = stream.readUTF();
        Integer temp = new Integer(s);
        int msgCnt = temp.intValue();
        int i;
        // DataSpec dp ;

        // Create a new message list and then read in all of the messages.
        ArrayList<String> msgList = new ArrayList<String>();

        for (i = 0; i < msgCnt; i++) {
            String msg = stream.readUTF();
            msgList.add(msg);
        }

        return msgList;
    }
}

// A utility class used to hold a DataSpecification.
class DataSpec implements Serializable {
	private static final long serialVersionUID = -7541117927089429909L;
	String name;
	String value;
	// String type;
	Integer customDetailTypeId;
}

